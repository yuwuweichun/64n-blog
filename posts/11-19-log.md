---
title: "11-19 面经"
date: "2025-11-19"
description: "11-19 面经"
keywords: "爬楼梯，防抖与节流，异步"
---

### 手撕-爬楼梯
[leetcode-70-爬楼梯](./leetcode-70.md)

### 手撕-防抖与节流（头/尾模式）
[防抖节流](./debounce-throttle.md)

### 手撕-调用 remoteAdd 函数，进行数组累加
考察三个方面：
- 异步
- 并发
- 缓存

```javascript
function remoteAdd(num1, num2) {
    return new Promise((resolve) => {
        resolve(num1 + num2);
    });
}
function asyncArraySum(arr) {
  let sum = 0;
  for (const num of arr) {
    // 如何并发计算？
    sum = await remoteAdd(sum, num);
  }
  return sum;
}
// 如何对计算结果缓存，避免重复计算
const numbers1 = [1, 2, 3, 4, 5];
const numbers2 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
```

### React和Vue的异同

### MVVM

### 什么是响应式
数据变化时,依赖该数据的视图/计算属性自动更新,无需手动操作DOM。
### React和Vue的响应式原理
Vue: Vue2用Object.defineProperty劫持getter/setter收集依赖、触发更新;Vue3用Proxy代理整个对象
React: 通过setState触发diff和重新渲染,需手动调用更新方法
### 什么是依赖
被响应式数据引用的计算属性、watch、组件渲染函数等,数据变化时需要重新执行的目标。
### 你的项目中用Pinia状态管理库是做了什么事情
集中管理全局状态(如用户信息),支持跨组件共享、持久化、devtools调试。
### 为什么不使用全局的ref，Pinia的优势在哪里，解决了什么问题？
全局ref难以追踪修改来源、没有命名空间隔离、无法利用devtools、缺少类型推断。Pinia提供模块化、插件系统、SSR支持。
### Express中间件原理（洋葱模型）
洋葱模型:请求依次进入中间件(外→内),响应时逆序退出(内→外)。通过next()串联,可在请求/响应阶段插入逻辑。
### ESlint和Prettier怎么配置，pre-commit钩子，有没有了解过Husky和lint-staged？
#### Husky做了什么，解决了什么问题
Git本身的 hooks 都放在 `.git/hooks` 目录下，但这些文件
- 不会被 Git 版本控制
- 不方便多人协作
- 不好用（手动chmod+x/添加执行权限，变成可执行文件以程序的方式运行）
- 不易维护
Husky做了：
- 将 Git hooks 脚本放在`.husky`下，方便版本控制和多人协作
- 自动让 Git 加载这些 hooks
- 用Node命令配置 hooks（`npx husky add .husky/pre-commit "npm test"`）

Husky让你方便的在 Git 生命周期的各个阶段运行脚本，从而实现代码质量检查、测试等自动化任务。
#### lint-staged做了什么，解决了什么问题
lint-staged 的作用是：
只对 Git 暂存区（staged）的文件执行 lint / 格式化

如果你直接在 pre-commit 钩子中运行 ESLint 或 Prettier，会检查整个代码库，效率低下且可能引入不必要的更改。lint-staged 只会检查那些被暂存（staged）的文件，提高了效率并减少了不必要的更改。

### 平时是如何使用git的，遇到冲突怎么解决，具体讲一下冲突修改完之后要执行哪些命令
[git工作流](./git-flow.md)
[合并冲突](./git-conflict.md)

### 懒加载和首屏不加载
懒加载: 图片/组件按需加载(IntersectionObserver、动态import)
首屏优化: 路由懒加载、代码分割、SSR、预渲染
### 请求发起到服务器，接收服务器回包到渲染页面的整个流程
DNS解析→TCP三次握手→HTTP请求→服务器处理→返回HTML→解析HTML→加载CSS/JS→构建DOM树+CSSOM树→渲染树→Layout→Paint

### 常用的攻击手段和防御手段


