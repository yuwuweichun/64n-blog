---
title: '11-18 面经'
date: '2025-11-18'
description: '11-18 面经'
keywords: '双等与三等,简单请求,复杂请求,哈希表简单实现,useEffect,副作用,'
---
### 双等与三等的区别

**双等号（==）** 会进行类型转换后再比较值是否相等，**三等号（===）** 严格比较，不进行类型转换，要求类型和值都相等。

```javascript
// 双等示例
1 == '1'    // true（字符串转数字后比较）
0 == false  // true（布尔转数字后比较）
null == undefined  // true（特殊规则）

// 三等示例
1 === '1'   // false（类型不同）
0 === false // false（类型不同）
null === undefined  // false（类型不同）
```

**最佳实践**：优先使用 `===`，避免隐式类型转换带来的意外行为。

### 双等类型转换
例如`'1'==1`是字符串'1'转换为数字1，还是数字1转换为字符串'1'，为什么？

在 `'1' == 1` 中，是**字符串 `'1'` 转换为数字 `1`**。

**原因**：根据 ECMAScript 规范中 `==` 的类型转换规则：
- 当字符串和数字比较时，**字符串会通过 `ToNumber` 转换为数字**
- 转换优先级：布尔 → 数字，字符串 → 数字，对象 → 原始值

```javascript
'1' == 1
// 步骤：
// 1. 检测到字符串和数字比较
// 2. 将 '1' 转换为 Number('1') = 1
// 3. 比较 1 == 1，结果为 true
```

**记忆技巧**：在 `==` 比较中，数字类型优先级更高，其他类型会向数字靠拢。

### {}=={}结果是什么，为什么？

结果是 **`false`**。

**原因**：
1. 两个对象字面量 `{}` 在内存中是**不同的引用**（不同的内存地址）
2. 对象的比较（无论 `==` 还是 `===`）都是**引用比较**，而非值比较
3. 只有当两个变量指向同一个对象时才相等

```javascript
{} == {}   // false（不同对象引用）
{} === {}  // false（同样是引用比较）

// 只有指向同一对象才相等
const obj1 = {};
const obj2 = obj1;
obj1 == obj2   // true（同一引用）
obj1 === obj2  // true（同一引用）
```

**特殊情况**：如果需要比较对象的"值"（属性内容），需要手动实现深度比较或使用工具库（如 Lodash 的 `_.isEqual`）。

### CORS中什么是简单请求，什么是复杂请求?

**简单请求**满足以下所有条件：
1. 请求方法是 `GET`、`HEAD` 或 `POST`
2. HTTP 头部仅包含安全字段（如 `Accept`、`Accept-Language`、`Content-Language`、`Content-Type`）
3. `Content-Type` 仅为 `text/plain`、`multipart/form-data` 或 `application/x-www-form-urlencoded`

**复杂请求**（预检请求）：不满足简单请求条件的请求，浏览器会先发送 `OPTIONS` 预检请求。

```javascript
// 简单请求示例
fetch('https://api.example.com/data', {
    method: 'GET'
});

// 复杂请求示例（会触发预检）
fetch('https://api.example.com/data', {
    method: 'PUT',  // 非简单方法
    headers: {
        'Content-Type': 'application/json'  // 非简单Content-Type
    }
});
```

### 现在有一个数组，数组元素都是非引用类型，如何进行一个去重，思路是什么？

**使用 Set 去重**（最简洁方式）：

```javascript
const arr = [1, 2, 2, 3, 4, 4, 5];
const uniqueArr = [...new Set(arr)];
// 结果: [1, 2, 3, 4, 5]
```

**思路**：`Set` 数据结构自动去除重复值，利用扩展运算符转回数组。

### 不用Set，分析一下时间复杂度和空间复杂度分别是多少？

**方法1：双层循环（indexOf）**
```javascript
function unique(arr) {
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        if (result.indexOf(arr[i]) === -1) {
            result.push(arr[i]);
        }
    }
    return result;
}
```
- **时间复杂度**：`O(n²)`（indexOf 需要遍历 result 数组）
- **空间复杂度**：`O(n)`（result 数组）

**方法2：对象/哈希表**
```javascript
function unique(arr) {
    const obj = {};
    const result = [];
    for (let i = 0; i < arr.length; i++) {
        if (!obj[arr[i]]) {
            obj[arr[i]] = true;
            result.push(arr[i]);
        }
    }
    return result;
}
```
- **时间复杂度**：`O(n)`（对象查找是 O(1)）
- **空间复杂度**：`O(n)`（obj 对象 + result 数组）

### 哈希表简单实现

```javascript
/* 键值对 Number -> String */
class Pair {
    constructor(key, val) {
        this.key = key;
        this.val = val;
    }
}

/* 基于数组实现的哈希表 */
class ArrayHashMap {
    #buckets; // 私有类字段，在类内部存储每个实例的私有数据。
    constructor() {
        // 初始化数组，包含 100 个桶
        this.#buckets = new Array(100).fill(null);
    }

    /* 哈希函数 */
    #hashFunc(key) {
        return key % 100;
    }

    /* 查询操作 */
    get(key) {
        let index = this.#hashFunc(key);
        let pair = this.#buckets[index];
        if (pair === null) return null;
        return pair.val;
    }

    /* 添加操作 */
    set(key, val) {
        let index = this.#hashFunc(key);
        this.#buckets[index] = new Pair(key, val);
    }

    /* 删除操作 */
    delete(key) {
        let index = this.#hashFunc(key);
        // 置为 null ，代表删除
        this.#buckets[index] = null;
    }

    /* 获取所有键值对 */
    entries() {
        let arr = [];
        for (let i = 0; i < this.#buckets.length; i++) {
            if (this.#buckets[i]) {
                arr.push(this.#buckets[i]);
            }
        }
        return arr;
    }

    /* 获取所有键 */
    keys() {
        let arr = [];
        for (let i = 0; i < this.#buckets.length; i++) {
            if (this.#buckets[i]) {
                arr.push(this.#buckets[i].key);
            }
        }
        return arr;
    }

    /* 获取所有值 */
    values() {
        let arr = [];
        for (let i = 0; i < this.#buckets.length; i++) {
            if (this.#buckets[i]) {
                arr.push(this.#buckets[i].val);
            }
        }
        return arr;
    }

    /* 打印哈希表 */
    print() {
        let pairSet = this.entries();
        for (const pair of pairSet) {
            console.info(`${pair.key} -> ${pair.val}`);
        }
    }
}
```

### 在什么情况下需要用到useEffect这个hook？

当组件需要**与外部系统同步**时使用 `useEffect`：

1. **数据获取**：从 API 请求数据
2. **订阅事件**：监听 WebSocket、浏览器事件
3. **DOM 操作**：直接操作 DOM 元素
4. **定时器**：设置 `setTimeout`/`setInterval`
5. **第三方库集成**：初始化图表、地图等

```javascript
useEffect(() => {
    // 副作用代码
    const timer = setTimeout(() => console.log('延迟执行'), 1000);
    
    // 清理函数（组件卸载时执行）
    return () => clearTimeout(timer);
}, [dependencies]);  // 依赖数组
```

### 解释一下什么叫副作用

**副作用（Side Effect）** 是指函数执行时，除了返回值外，还对外部环境产生了影响的操作。

**常见副作用**：
- 修改全局变量
- 发送网络请求
- 操作 DOM
- 读写本地存储
- 订阅/取消订阅事件
- 打印日志

```javascript
// 纯函数（无副作用）
function add(a, b) {
    return a + b;
}

// 有副作用的函数
let count = 0;
function addWithSideEffect(a, b) {
    count++;  // 修改外部变量（副作用）
    console.log('计算中...');  // 打印日志（副作用）
    return a + b;
}
```

### 怎么定义一个是不是副作用？

**判断标准**：
1. **函数是否纯净**：相同输入是否总返回相同输出？
2. **是否影响外部**：是否修改了函数作用域外的状态？
3. **是否可观测**：除了返回值，外部能否观测到其他变化？

**具体检查点**：
- ❌ 修改传入的参数对象
- ❌ 修改全局变量/闭包变量
- ❌ 发起网络请求
- ❌ 操作文件/数据库
- ❌ 调用有副作用的函数
- ✅ 只进行计算和返回值

```javascript
// 无副作用（纯函数）
function multiply(a, b) {
    return a * b;
}

// 有副作用（修改外部数组）
function addToArray(arr, item) {
    arr.push(item);  // 副作用：修改了传入的数组
}

// 无副作用（返回新数组）
function addToArrayPure(arr, item) {
    return [...arr, item];  // 不修改原数组
}
```

**React 中的副作用**：任何不属于"根据 props/state 计算渲染输出"的操作都是副作用，需要放在 `useEffect` 中。

### 将一个你项目中的亮点
...

---
参考：
- [Hello算法-哈希表简单实现](https://www.hello-algo.com/chapter_hashing/hash_map/#612)
- [React-useEffect](https://react.dev/reference/react/useEffect)
- [前端中的副作用是什么 | 程序员零塔的小破站](https://www.zerotower.cn/2025/02/what's-effect/)
---
